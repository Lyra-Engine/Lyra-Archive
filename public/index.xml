<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lyra Engine</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Lyra Engine</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Jul 2025 12:00:00 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RHI: D3D12</title>
      <link>http://localhost:1313/posts/rhi-d3d12/</link>
      <pubDate>Sun, 20 Jul 2025 12:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/rhi-d3d12/</guid>
      <description>&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;&#xA;&lt;p&gt;I have no prior experience writing D3D12, but my complacency after mastering Vulkan has&#xA;made me blindly think I can learn as I implement this backend. In fact, I did manage to&#xA;implement this backend, but with AI&amp;rsquo;s help.&lt;/p&gt;&#xA;&lt;h2 id=&#34;mapping&#34;&gt;Mapping&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;WebGPU&lt;/th&gt;&#xA;          &lt;th&gt;D3D12&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUAdapter&lt;/td&gt;&#xA;          &lt;td&gt;IDXGIAdapter1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSurface&lt;/td&gt;&#xA;          &lt;td&gt;IDXGISwapChain3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUDevice&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12Device&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUCommandBuffer&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12GraphicsCommandList&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPURenderPipeline&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12PipelineState&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUComputePipeline&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12PipelineState&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUPipelineLayout&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12RootSignature&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroupLayout&lt;/td&gt;&#xA;          &lt;td&gt;D3D12_ROOT_PARAMETER1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroup&lt;/td&gt;&#xA;          &lt;td&gt;D3D12_CPU_DESCRIPTOR_HANDLE&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBuffer&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12Resource&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSampler&lt;/td&gt;&#xA;          &lt;td&gt;D3D12_CPU_DESCRIPTOR_HANDLE&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTexture&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12Resource&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTextureView&lt;/td&gt;&#xA;          &lt;td&gt;D3D12_CPU_DESCRIPTOR_HANDLE&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUShaderModule&lt;/td&gt;&#xA;          &lt;td&gt;std::uint8_t*&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUFence&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12Fence&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUQuerySet&lt;/td&gt;&#xA;          &lt;td&gt;ID3D12QueryHeap&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;As you might have noticed, the mapping from WebGPU to D3D12 is not as straightforward&#xA;as the mapping to Vulkan. Here are some items that are worth mentioning.&lt;/p&gt;</description>
    </item>
    <item>
      <title>RHI: Vulkan</title>
      <link>http://localhost:1313/posts/rhi-vulkan/</link>
      <pubDate>Sun, 20 Jul 2025 11:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/rhi-vulkan/</guid>
      <description>&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;&#xA;&lt;p&gt;The Vulkan implementation has been an easy one, as I can see the WebGPU API&#xA;design is largely based on Vulkan&amp;rsquo;s API. Therefore a lot of the API implementation&#xA;becomes direct translation. Here&amp;rsquo;s a concept mapping between WebGPU and Vulkan.&lt;/p&gt;&#xA;&lt;h2 id=&#34;mapping&#34;&gt;Mapping&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;WebGPU&lt;/th&gt;&#xA;          &lt;th&gt;Vulkan&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUAdapter&lt;/td&gt;&#xA;          &lt;td&gt;VkPhysicalDevice&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSurface&lt;/td&gt;&#xA;          &lt;td&gt;VkSurfaceKHR + VkSwapchainKHR&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUDevice&lt;/td&gt;&#xA;          &lt;td&gt;VkDevice&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUCommandBuffer&lt;/td&gt;&#xA;          &lt;td&gt;VkCommandBuffer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPURenderPipeline&lt;/td&gt;&#xA;          &lt;td&gt;VkPipeline&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUComputePipeline&lt;/td&gt;&#xA;          &lt;td&gt;VkPipeline&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUPipelineLayout&lt;/td&gt;&#xA;          &lt;td&gt;VkPipelineLayout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroupLayout&lt;/td&gt;&#xA;          &lt;td&gt;VkDescriptorSetLayout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroup&lt;/td&gt;&#xA;          &lt;td&gt;VkDescriptorSet&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBuffer&lt;/td&gt;&#xA;          &lt;td&gt;VkBuffer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSampler&lt;/td&gt;&#xA;          &lt;td&gt;VkSampler&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTexture&lt;/td&gt;&#xA;          &lt;td&gt;VkImage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTextureView&lt;/td&gt;&#xA;          &lt;td&gt;VkImageView&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUShaderModule&lt;/td&gt;&#xA;          &lt;td&gt;VkShaderModule&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUFence&lt;/td&gt;&#xA;          &lt;td&gt;VkFence + VkSemaphore&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUQuerySet&lt;/td&gt;&#xA;          &lt;td&gt;VkQueryPool&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;Noteworthily, GPUFence can be used on CPU side, while VkSemaphore is supposed to work&#xA;only for GPU/GPU synchronization. However, Vulkan 1.2 introduced timeline semaphore&#xA;which can be used on both CPU and GPU. Therefore timeline semaphore is used in most&#xA;of the places (except for swapchain, beceause swapchain only works with binary semaphore).&lt;/p&gt;</description>
    </item>
    <item>
      <title>RHI Overview</title>
      <link>http://localhost:1313/posts/rhi-overview/</link>
      <pubDate>Sun, 20 Jul 2025 10:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/rhi-overview/</guid>
      <description>&lt;h2 id=&#34;webgpu-api&#34;&gt;WebGPU API&lt;/h2&gt;&#xA;&lt;p&gt;As the previous post has mentioned, I have chosen to use&#xA;&lt;a href=&#34;https://www.w3.org/TR/webgpu/&#34;&gt;WebGPU&lt;/a&gt; API as the foundation for my RHI&#xA;abstraction layer. In this post, I will talk about the deviations from this&#xA;foundation API.&lt;/p&gt;&#xA;&lt;h2 id=&#34;explicit-lifetime-management&#34;&gt;Explicit Lifetime Management&lt;/h2&gt;&#xA;&lt;p&gt;WebGPU automatically tracks the lifetime of all GPU objects. This is one of the key&#xA;points WebGPU is simpler to use. It is similar to Metal 1.0 in a way. However, the&#xA;trend of modern rendering is that graphics API reduces overhead by asking users to&#xA;manage their own stuff. Therefore I choose to let users create/destroy GPU objects&#xA;manually.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lyra Engine Overview</title>
      <link>http://localhost:1313/posts/lyra-engine-overview/</link>
      <pubDate>Sun, 20 Jul 2025 09:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/lyra-engine-overview/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;Lyra-Engine&lt;/strong&gt; is my attempt to create a rendering engine.&lt;/p&gt;&#xA;&lt;p&gt;I have always been fond of creating a complete game / rendering engine from scratch.&#xA;In the past, I have made multiple attempts but none of them got very far due to the&#xA;lack of experience. &lt;strong&gt;Lyra-Engine&lt;/strong&gt; is currently my most promising project.&#xA;&lt;strong&gt;Lyra-Engine&lt;/strong&gt; uses a modular design, similar to &lt;strong&gt;TheMachinery&lt;/strong&gt;, except that&#xA;&lt;strong&gt;Lyra-Engine&lt;/strong&gt; chooses to use C++, and does not strictly follow C ABI (as it only&#xA;introduces more trouble for me at the current stage).&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
