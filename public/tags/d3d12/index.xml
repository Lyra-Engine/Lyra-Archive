<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>D3D12 on Lyra Engine</title>
    <link>http://localhost:1313/tags/d3d12/</link>
    <description>Recent content in D3D12 on Lyra Engine</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Jul 2025 12:00:00 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/d3d12/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RHI: Vulkan</title>
      <link>http://localhost:1313/posts/rhi-d3d12/</link>
      <pubDate>Sun, 20 Jul 2025 12:00:00 -0500</pubDate>
      <guid>http://localhost:1313/posts/rhi-d3d12/</guid>
      <description>&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;&#xA;&lt;p&gt;The Vulkan implementation has been an easy one, as I can see the WebGPU API&#xA;design is largely based on Vulkan&amp;rsquo;s API. Therefore a lot of the API implementation&#xA;becomes direct translation. Here&amp;rsquo;s a concept mapping between WebGPU and Vulkan.&lt;/p&gt;&#xA;&lt;h2 id=&#34;concepts-mapping&#34;&gt;Concepts Mapping&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;WebGPU&lt;/th&gt;&#xA;          &lt;th&gt;Vulkan&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUAdapter&lt;/td&gt;&#xA;          &lt;td&gt;VkPhysicalDevice&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSurface&lt;/td&gt;&#xA;          &lt;td&gt;VkSurfaceKHR + VkSwapchainKHR&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUDevice&lt;/td&gt;&#xA;          &lt;td&gt;VkDevice&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUCommandBuffer&lt;/td&gt;&#xA;          &lt;td&gt;VkCommandBuffer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPURenderPipeline&lt;/td&gt;&#xA;          &lt;td&gt;VkPipeline&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUComputePipeline&lt;/td&gt;&#xA;          &lt;td&gt;VkPipeline&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUPipelineLayout&lt;/td&gt;&#xA;          &lt;td&gt;VkPipelineLayout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroupLayout&lt;/td&gt;&#xA;          &lt;td&gt;VkDescriptorSetLayout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBindGroup&lt;/td&gt;&#xA;          &lt;td&gt;VkDescriptorSet&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUBuffer&lt;/td&gt;&#xA;          &lt;td&gt;VkBuffer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUSampler&lt;/td&gt;&#xA;          &lt;td&gt;VkSampler&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTexture&lt;/td&gt;&#xA;          &lt;td&gt;VkImage&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUTextureView&lt;/td&gt;&#xA;          &lt;td&gt;VkImageView&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUShaderModule&lt;/td&gt;&#xA;          &lt;td&gt;VkShaderModule&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUFence&lt;/td&gt;&#xA;          &lt;td&gt;VkFence + VkSemaphore&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;GPUQuerySet&lt;/td&gt;&#xA;          &lt;td&gt;VkQueryPool&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;Noteworthily, GPUFence can be used on CPU side, while VkSemaphore is supposed to work&#xA;only for GPU/GPU synchronization. However, Vulkan 1.2 introduced timeline semaphore&#xA;which can be used on both CPU and GPU. Therefore timeline semaphore is used in most&#xA;of the places (except for swapchain, beceause swapchain only works with binary semaphore).&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
